#!/bin/sh

###############################################################################
#	F.U.L.L.S.T.O.R.Y initramfs live media init functions
#
#	Copyright:	© 2007-2010 Kel Modderman <kel@otaku42.de>
#			© 2006-2011 Stefan Lippers-Hollmann <s.l-h@gmx.de>
#			© 2007-2011 Niall Walsh <niallwalsh@users.berlios.de>
#	License:	GPLv2
#
#	F.U.L.L.S.T.O.R.Y Project Homepage:
#	http://developer.berlios.de/projects/fullstory
#
#	This script snippet needs to get executed under busybox sh, due to
#	using awk, klibc sh doesn't provide an awk implementation

###############################################################################
# 	use information exported via proc and sysfs to make block device list
# 	bubble-sort cdrom devices to top of block device stack
###############################################################################
fll_finger_blockdevs()
{
	unset FINGERED

	#
	# cdrom device detection. we could glob /sys/block/ and use udevadm
	# info output to identify devices with ID_CDOM=1 in environment, but
	# that method has proven to be unreliable ...
	#
	if [ "${FLL_FROMHD}" != "yes" ] && [ -r /proc/sys/dev/cdrom/info ]; then
		FINGERED=$(awk -F: '
			$1 == "drive name" && NF > 1 {
				split($2, node, " ")
				for (n in node) {
					if (!system("test -b /dev/" node[n]))
						cdrom[i++] = "/dev/" node[n]
				}
			}
			END {
				for (c in cdrom)
					print cdrom[c]
			}
		' /proc/sys/dev/cdrom/info)

		#
		# only detect non cdrom devices if fromhd/fromiso/persist
		# cheatcode was used.
		#
		if [ "${FLL_PERSIST}" != "yes" ]; then
			echo "${FINGERED}"
			return
		fi
	fi

	#
	# disk device detection
	#
	for path in /sys/block/*; do
		[ -e "${path}" ] || continue

		disk=${path#/sys/block/}

		if [ "${FINGERED}" ] && echo "${FINGERED}" | \
			grep -q -w "${disk}"; then
		   	continue
		fi

		case "${disk}" in
			ps3d*)
				#
				# udev seems to not know much about these
				# special PS3 specific block devices, so
				# avoid disk type checking
				#
				;;
			nbd*)
				#
				# udev doesn't reflect state of nbd device
				#
				[ -n "${FLL_NBD}" ] || continue
				nbd-client -c ${disk} > /dev/null || continue
				;;
			*)
				udevadm info -q env -p "${path}" | \
					grep -q 'ID_TYPE=disk' || continue
				;;
		esac

		#
		# use shell wildcard to expand partitions from sysfs hier
		#
		for sub_path in ${path}/${disk}[1-9]* ${path}/${disk}p[1-9]*; do
			# trying p between disk and partition number for nbd
			[ -e "${sub_path}" ] || continue

			part="${sub_path#${path}/}"

			if [ -b "/dev/${part}" ]; then
				FINGERED="${FINGERED} /dev/${part}"
			fi
		done

		#
		# also attempt to probe the base device, in some cases this is
		# the only partition
		#
		if [ -b "/dev/${disk}" ]; then
			FINGERED="${FINGERED} /dev/${disk}"
		fi
	done

	echo ${FINGERED}
}
###############################################################################
# 	identify filesystem type of block device
###############################################################################
fll_finger_fstype()
{
	unset FSTYPE
	unset ID_FS_TYPE

	eval $(/sbin/blkid -o udev -u filesystem -p ${1} | grep ^ID_FS_TYPE)

	if [ "${ID_FS_TYPE}" ] ; then
		FSTYPE="${ID_FS_TYPE}"
		export FSTYPE
		return 0
	fi
	
	return 1
}
###############################################################################
#	modprobe loop and wait for device node creation
###############################################################################
fll_setup_dev_loop()
{
	#
	# load loop device support
	#
	modprobe "${MODPROBE_OPTIONS}" loop >/dev/null 2>&1
	
	#
	# loop around for max of 5 seconds and wait for /dev/loop* device nodes
	#
	LOOP_WAIT="10"

	while [ "${LOOP_WAIT}" -gt 0 ]; do
		c=0
		# TODO
		# it did check /dev/loop* and return 0 if anything existed
		for l in 0 1 2 3; do
			if [ -e "/dev/loop${l}" ]; then
				c=$((${c}+1))
			fi
		done
		if [ "${c}" -eq "4" ]; then
			return 0
		fi
		sleep 1
		LOOP_WAIT=$(( ${LOOP_WAIT} - 1 ))
	done

	panic "Unable to setup loop mounted device, no loop device nodes exist"
}
###############################################################################
#	generic mount function usage: fll_mount fs src mnt options
###############################################################################
fll_mount()
{
	FS="${1}"
	SRC="${2}"
	DST="${3}"
	shift 3

	unset FLL_MOUNT_OPTS

	case "${FS}" in
		iso9660|squashfs|udf)
			FLL_MOUNT_OPTS="ro"

			if [ -f "${SRC}" ] && [ ! -b "${SRC}" ]; then
				fll_setup_dev_loop
				LOOP_SRC_DEV="$(losetup -f)"
				if ! losetup "${LOOP_SRC_DEV}" "${SRC}"; then
					panic "Failed to setup loop device for ${SRC} on ${LOOP_SRC_DEV}"
				fi
				SRC=${LOOP_SRC_DEV}
			fi
			;;
		ntfs)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},dmask=0022,fmask=0133"
			else
				FLL_MOUNT_OPTS="ro,dmask=0022,fmask=0133"
			fi
			;;
		vfat)
			#
			# we need this for FLL_IMAGE on DOS-filesystems
			#
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="${@},shortname=winnt,umask=0"
			else
				FLL_MOUNT_OPTS="shortname=winnt,umask=0"
			fi
			;;
		suspend|swap|luks|lvm*)
			#
			# filesystem blacklist
			#
			return 1
			;;
		*)
			if [ "${#}" -gt 0 ]; then
				FLL_MOUNT_OPTS="noatime,${@}"
			fi
			;;
	esac

	if [ "${FLL_MOUNT_OPTS}" ]; then
		mount -t ${FS} -o ${FLL_MOUNT_OPTS} ${SRC} ${DST} >/dev/null 2>&1
		return "${?}"
	else
		mount -t ${FS} ${SRC} ${DST} >/dev/null 2>&1
		return "${?}"
	fi
}
###############################################################################
#	umount and remove a stack of mount points
###############################################################################
fll_umount()
{
	[ "${#}" -ge 1 ] || return 0
	
	for m in ${@}; do
		grep -q "${m}" /proc/mounts || continue

		umount "${m}" 2>/dev/null

		# if a plain umount fails, try the lazy option
		# if the lazy option fails then panic with error
		if [ "${?}" -ne 0 ]; then
			umount -l "${m}" || panic "failed to umount ${m}"
		fi

		rmdir "${m}"
	done
}
###############################################################################
#      calculate total, used and unused memory: MEMTOTAL MEMUSED MEMFREE
###############################################################################
fll_meminfo()
{
	awk '
		/^MemTotal:/ { total=$2 }
		/^(MemFree|Buffers|Cached):/ { free+=$2 }
		END {
			printf("MEMTOTAL=%d\n", int(total) / 1024)
			printf("MEMFREE=%d\n",  int(free) / 1024)
			printf("MEMUSED=%d\n",  (int(total) - int(free)) / 1024)
		}
	' /proc/meminfo
}
###############################################################################
#	utility function to display update when cp'ing live media into ram
###############################################################################
fll_copy_with_perc()
{
	if [ ! -f "${1}" ] || [ ! -d "${2}" ]; then
		return 1
	fi

	#
	# background the copy, grab the process id
	#
	cp "${1}" "${2}/${1##*/}" &
	
	awk -v pid="${!}" -v origfile="${1}" -v destfile="${2}/${1##*/}" '
		function size_of(file,    cmd, size)
		{
			cmd = "ls -l " file
			if ((cmd | getline) > 0) {
				size = int($5 / 1024)
				close(cmd)
				if (size > 0)
					return size
			}

			return 0
		}

		BEGIN {
			do {
				if (system("test -f " destfile) == 0) {
					break
				}
				else if (system("sleep 1") == 0) {
					wait++
				}
				else {
					exit(1)
				}
			} while (wait < 15)

			size_dest = perc = 0
			size_orig = size_of(origfile)
			if (size_orig <= 0)
				exit(1)

			do {
				perc = int(100 * size_of(destfile) / size_orig)
				if (perc < 100) {
					printf("\r[")
					for (i = 0; i <= perc; i += 2)
						printf("=")
					printf(">")
					for (i = perc; i < 100; i += 2)
						printf(" ")
					printf("]  ")
					printf("%02d%s", perc, "%")
				}
			} while (system("test -d /proc/" pid) == 0 &&
				 system("sleep 2") == 0)

			#
			# destfile size is > origfile size on tmpfs
			#
			if (size_of(destfile) >= size_orig) {
				printf("\r[")
				for (i = 0; i <= 100; i += 2)
					printf("=")
				printf("=] ")
				printf("%s\n", "100%")
				exit(0)
			}
			else {
				printf("\nFailed to copy %s to ram\n", origfile)
				exit(1)
			}
		}'
	
	return ${?}
}
###############################################################################
#	md5sum checker
###############################################################################
fll_md5sum_check()
{
	if [ ! -f "${1}/md5sums" ]; then
		printf "No md5sums file found on live media.\n"
		return 1
	fi

	if ( cd "${1}" && md5sum -c "md5sums" ); then
		return 0
	else
		printf "*******************************\n"
		printf "***** MD5SUM CHECK FAILED *****\n"
		printf "*******************************\n"
		return 1
	fi
}
###############################################################################
#       find and copy firmware
###############################################################################
fll_firmware() {
	# FLL_MOUNT_LOOP skips sleeping the first loop round
	unset FLL_MOUNT_LOOP
	# set FROMHD so hd's will be fingered
	FLL_FROMHD_REAL="${FLL_FROMHD}"
	FLL_FROMHD="yes"
	# don't wait longer for firmware then root
	# FLL_ROOTDELAY may already have been decreased
	while [ "${FLL_ROOTDELAY}" -gt 0 ]; do
		# sleep time, we skip sleeping for first pass
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" -eq 1 ]; then
				printf "Waiting for up to ${FLL_ROOTDELAY}s for devices to settle...\n"
			fi
			sleep "${FLL_MOUNT_INTERVAL}"
			FLL_ROOTDELAY=$(( ${FLL_ROOTDELAY} - ${FLL_MOUNT_INTERVAL} ))
		fi
		FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		# FLL_FIRMDEVS holds the list of new devices to scan
		unset FLL_FIRMDEVS
		for dev in $(fll_finger_blockdevs); do
			unset firmdevdone
			for check in ${FLL_FIRMMNTS} ; do
				if [ ${check} = ${dev##*/} ]; then
					firmdevdone="Y"
					break
				fi
			done
			if [ -z "${firmdevdone}" ]; then
				FLL_FIRMDEVS="${FLL_FIRMDEVS} ${dev}"
			fi
		done
		# end loop if there is nothing new to check
		if [ -z "${FLL_FIRMDEVS}" ]; then
			continue
		fi
		# try each new device
		for dev in ${FLL_FIRMDEVS}; do
			# FLL_BLOCKMNT		- tracks current mount point
			unset FLL_BLOCKMNT
			# determine filesystem type of block device
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				# setup mount point
				FLL_BLOCKMNT="/fll/${dev##*/}"
				mkdir -p "${FLL_BLOCKMNT}"
				# mount block device on FLL_BLOCKMNT for probe
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					# add dev name to FLL_FIRMMNTS to supress rechecking
					FLL_FIRMMNTS="${FLL_FIRMMNTS} ${dev##*/}"
					# check for firmware dir
					if [ -d "${FLL_BLOCKMNT}/${FLL_IMAGE_DIR}/firmware" ]; then
						FLL_FIRMWARE_FOUND="${dev}"
						if cp -R ${FLL_BLOCKMNT}/${FLL_IMAGE_DIR}/firmware/* /${rootmnt}/lib/firmware ; then
							printf "Copied firmware from ${dev##*/}\n"
						fi
					fi
					fll_umount "${FLL_BLOCKMNT}"
				fi
			fi
			#
			# break dev and sleep loops if you have firmware
			#
			if [ "${FLL_FIRMWARE_FOUND}" ]; then
				break 2
			fi
		done
	done
	# Restore real FROMHD value in case something else decides to use it
	FLL_FROMHD="${FLL_FROMHD_REAL}"
	if [ -z "${FLL_FIRMWARE_FOUND}" ]; then
		echo "Failed to find firmware directory"
	fi
}
###############################################################################
# 	define mountroot() for init
###############################################################################
mountroot()
{
	#
	# source distro-defaults
	#
	. /etc/default/distro
	
	#
	# parse fll options given on cmdline
	#
	for opt in $(cat /proc/cmdline); do
		case "${opt}" in
			firmware)
				FLL_FIRMWARE="yes"
				;;
			fll=debug)
				set -x
				;;
			fromhd*)
				FLL_FROMHD="yes"
				# define dev node
				case "${opt}" in
					fromhd=*)
						FLL_FROMHD_DEV="${opt#fromhd=}"
						;;
				esac
				;;
			fromiso*)
				FLL_FROMHD="yes"
				FLL_FROMISO="yes"
				# define iso name
				case "${opt}" in
					fromiso=*)
						FLL_MEDIA_NAME="${opt#fromiso=}"
						;;
				esac
				;;
			image_dir=*)
				FLL_IMAGE_DIR="${opt#image_dir=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			image_name=*)
				FLL_IMAGE_FILE="${opt#image_name=}"
				FLL_IMAGE_LOCATION="${FLL_IMAGE_DIR}/${FLL_IMAGE_FILE}"
				;;
			nbdroot=*)
				# triggers finger_blockdevs
				FLL_FROMHD="yes"
				# need to know to tell finger_blockdevs to check nbd*
				FLL_NBD="${opt#nbdroot=}"
				;;
			persist*)
				FLL_PERSIST="yes"
				FLL_PERSIST_FILE="${FLL_DISTRO_NAME}-rw"
				case "${opt}" in
					persist=*)
						FLL_PERSIST_FILE="${opt#persist=}"
						FLL_UNION_COWDIR="${opt#persist=}"
						;;
				esac
				;;
			quiet)
				if [ -f /proc/sys/kernel/printk ]; then
					echo "0" > /proc/sys/kernel/printk
				fi
				;;
			testcd|testdvd|md5sum)
				FLL_MD5SUM_CHECK="yes"
				;;
			toram)
				FLL_TORAM="yes"
				;;
			unionfs|aufs)
				# set FLL_UNION_MODULE in default/distro if needed
				# current default is dmsetup
				FLL_UNION_MODULE="${opt}"
				;;
		esac
	done

	#
	# Run scripts in local-top, like lvm2
	#
	[ "$quiet" != "y" ] && log_begin_msg "Running /scripts/local-top"
	run_scripts /scripts/local-top
	[ "$quiet" != "y" ] && log_end_msg

	#
	# debug checkpoint
	#
	maybe_break fll-premount

	#
	# total time in seconds to do device scans for; rootdelay= on kernel cmdline
	# upper limit on how long we wait for devices to show up before bailing out
	#
	if [ "${ROOTDELAY}" ] && [ "${ROOTDELAY}" -gt 0 ]; then
		FLL_ROOTDELAY="${ROOTDELAY}"
	else
		FLL_ROOTDELAY="30"
	fi
	
	#
	# interval between device scans
	#
	FLL_MOUNT_INTERVAL="3"

	#
	# these variables are created during $FLL_ROOTDELAY time loop
	#
	unset FLL_MOUNT_LOOP
	
	while [ "${FLL_ROOTDELAY}" -gt 0 ]; do
		#
		# refresh these for each loop
		#
		unset FLL_BLOCKDEVS

		#
		# sleep time, we skip FLL_ROOTDELAY interval for first pass for extra fast boot
		#
		if [ "${FLL_MOUNT_LOOP}" ]; then
			if [ "${FLL_MOUNT_LOOP}" -eq 1 ]; then
				printf "Waiting for up to ${FLL_ROOTDELAY}s for devices to settle...\n"
			fi
			sleep "${FLL_MOUNT_INTERVAL}"
			FLL_ROOTDELAY=$(( ${FLL_ROOTDELAY} - ${FLL_MOUNT_INTERVAL} ))
		fi

		#
		# mount loop counter, it enforces sleep interval on next loop
		#
		FLL_MOUNT_LOOP=$(( ${FLL_MOUNT_LOOP} + 1 ))
		
		#
		# determine block devices to be probed on this loop
		#
		if [ "${FLL_FROMHD_DEV}" ]; then
			#
			# user defined block device
			#
			case "${FLL_FROMHD_DEV}" in
				LABEL=*)
					FLL_BLOCKDEVS="/dev/disk/by-label/${FLL_FROMHD_DEV#LABEL=}"
					;;
				UUID=*)
					FLL_BLOCKDEVS="/dev/disk/by-uuid/${FLL_FROMHD_DEV#UUID=}"
					;;
				/dev/mapper/*)
					lvm vgchange -aly --ignorelockingfailure
					FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
					;;
				/dev/nbd*)
					# retry nbd if not running
					# nbd not safe to re-call without test
					# can hang if FLL_FROMHD_DEV is not from nbdroot
					# strip partition, only care if rootdev is alive
					FLL_NBD_DEV=${FLL_FROMHD_DEV#/dev/}
					/sbin/nbd-client -c ${FLL_NBD_DEV%p*} > /dev/null || /scripts/local-top/nbd
					FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
					;;
				*)
					FLL_BLOCKDEVS="${FLL_FROMHD_DEV}"
					;;
			esac
		else
			#
			# current list of block devices that may be probed for live media
			#
			FLL_BLOCKDEVS=$(fll_finger_blockdevs)
		fi
	
		if [ -z "${FLL_BLOCKDEVS}" ]; then
			continue
		fi

		FLL_BLOCKDEVS_PROBED=false

		for dev in ${FLL_BLOCKDEVS}; do
			#
			# FLL_BLOCKMNT		- tracks current mount point
			#
			# FLL_DOUMOUNT		- stack of mount points to be umounted at end of
			#			  loop
			#
			# FLL_DOMOVEMOUNT	- stack of mount points to be move mounted if the
			#			  loop is broken
			#
			# FLL_MEDIA_FOUND	- set only when we have the live media compressed
			#			  filesystem located and mounted
			#
			unset FLL_BLOCKMNT FLL_DOUMOUNT FLL_DOMOVEMOUNT FLL_MEDIA_FOUND
		
			#
			# determine filesystem type of block device
			#
			if fll_finger_fstype "${dev}" >/dev/null 2>&1; then
				if ! ${FLL_BLOCKDEVS_PROBED}; then
					printf "Probing devices\t"
					FLL_BLOCKDEVS_PROBED=true
				fi
				printf "[ ${dev#/dev/} ] "
				#
				# we have determined FSTYPE of the device, set FLL_BLOCKMNT
				#
				FLL_BLOCKMNT="/fll/${dev##*/}"
				mkdir -p "${FLL_BLOCKMNT}"
				#
				# save origin of media in variable for persitency
				#
				if [ "${FLL_PERSIST}" = "yes" ]; then
					FLL_PERSIST_BLOCKDEV="${dev}"
					FLL_PERSIST_BLOCKFSTYPE="${FSTYPE}"
					FLL_PERSIST_BLOCKMNT="${FLL_BLOCKMNT}"
				fi
				#
				# mount block device on FLL_BLOCKMNT for probe
				#
				if fll_mount "${FSTYPE}" "${dev}" "${FLL_BLOCKMNT}" ro; then
					#
					# add current FLL_BLOCKMNT to FLL_DOMOVEMOUNT stack
					#
					FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
					#
					# probe for iso image
					#
					if [ "${FLL_FROMISO}" = "yes" ]; then
						if [ -f "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME#/}" ]; then
							#
							# located iso, update dev description
							#
							FLL_MEDIA_FOUND="${dev}"
							printf "\n\n"
							printf "Detected ${FLL_MEDIA_NAME} "
							printf "on ${FLL_MEDIA_FOUND#/dev/}.\n"
							if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" >/dev/null 2>&1; then
								if [ "${FSTYPE}" != "iso9660" ] && [ "${FSTYPE}" != "udf" ]; then
									panic "${FLL_MEDIA_NAME} not an iso9660/ udf filesystem"
								fi
								mkdir -p /fll/fromiso
								#
								# loop mount iso on FLL_MEDIA_MOUNTPOINT
								#	
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_MEDIA_NAME}" /fll/fromiso; then
									if [ "${FLL_TORAM}" ]; then
										#
										# add block device mount point to umount stack
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
									fi
									#
									# update FLL_BLOCKMNT, FLL_DOMOVEMOUNT stack
									#
									FLL_BLOCKMNT="/fll/fromiso"
									FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
								else
									fll_umount ${FLL_DOUMOUNT}
									panic "Failed to mount ${FSTYPE} filesystem from iso image"
								fi
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "Failed to identify filesystem type of iso"
							fi
							printf "\n"
						fi
					fi
					#
					# probe for compressed filesystem
					#
					if [ -f "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" ]; then
						#
						# found FLL compressed filesystem
						# set/update FLL_MEDIA_FOUND variable (possibly already set via fromiso)
						#
						if [ -z "${FLL_MEDIA_FOUND}" ]; then
							printf "\n\n"
							FLL_MEDIA_FOUND="${dev}"
						fi
						#
						# debug checkpoint
						#
						maybe_break fll-found
						#
						# md5sum check
						#
						if [ "${FLL_MD5SUM_CHECK}" = "yes" ]; then
							printf "Performing md5sum integrity check of live media...\n\n"
							if fll_md5sum_check ${FLL_BLOCKMNT}; then
								printf "All md5sums verified successfully.\n\n"
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "Failed md5sum check!"
							fi
						fi
						#
						# prepare live filesystem
						#
						if fll_finger_fstype "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" >/dev/null 2>&1; then
							printf "Detected live ${FSTYPE} "
							if [ "${FLL_FROMISO}" = "yes" ]; then
								printf "filesystem on ${FLL_MEDIA_NAME}\n"
							else
								printf "filesystem on ${FLL_MEDIA_FOUND}\n"
							fi
							#
							# copy to tmpfs
							#
							if [ "${FLL_TORAM}" = "yes" ]; then
								#
								# required tmpfs size: compressed filesystem size + 10% buffer
								#
								eval $(fll_meminfo)
								# ls -l returns units in Bytes, divide by (1024*1024) to convert to MB
								FLL_TORAM_FSSIZE=$(ls -l "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" | \
									awk '{ printf("%d\n", int($5 * 1.1 / 1048576)) }')
								#
								# memory required to operate normally after iso has consumed memory
								# at least 32M is required
								#
								FLL_TORAM_MEMREQ=$(( ${FLL_TORAM_FSSIZE} + 32 ))
								#
								# do we have enough free memory for toram?
								#
								if [ "${MEMFREE}" -gt "${FLL_TORAM_MEMREQ}" ]; then
									#
									# prepare tmpfs, aka ramdisk
									#
									mkdir -p /fll/toram
									mount -n -t tmpfs -o size="${FLL_TORAM_FSSIZE}m" tmpfs /fll/toram
									mkdir -p "/fll/toram/${FLL_IMAGE_DIR}"
									#
									# copy compressed filesystem to tmpfs
									#
									printf "Copying live filesystem from ${dev#/dev/} to ram...\n"
									if fll_copy_with_perc "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "/fll/toram/${FLL_IMAGE_DIR}"; then
										#
										# add old mnt pnt to umount stack, update FLL_BLOCKMNT
										#
										FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
										FLL_BLOCKMNT="/fll/toram"
										FLL_DOMOVEMOUNT="${FLL_BLOCKMNT} ${FLL_DOMOVEMOUNT}"
									else
										if [ "${FLL_FROMISO}" = "yes" ]; then
											#
											# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
											#
											unset FLL_DOUMOUNT
										fi
										#
										# umount the tmpfs or run-init will not be happy
										#
										rm -rf "/fll/toram/${FLL_IMAGE_DIR}"
										fll_umount /fll/toram
										printf "\nContinuing boot from live media...\n"
									fi
								else
									printf "Insufficient free memory to copy live media into memory\n"
									printf "Required free memory: ${FLL_TORAM_MEMREQ}M\n"
									printf "\nContinuing boot from live media...\n"
									if [ "${FLL_FROMISO}" = "yes" ]; then
										#
										# we failed to copy iso contents to ram: reset FLL_DOUMOUNT stack
										#
										unset FLL_DOUMOUNT
									fi
								fi
							fi
							#
							# mount compressed filesystem, source directory: FLL_BLOCKMNT
							#
							mkdir -p "${FLL_MOUNTPOINT}"
							if [ -n "${FLL_UNION_MODULE}" ] && [ "${FLL_UNION_MODULE}" != "dmsetup" ] && fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}"; then
								printf "Mounted ${FSTYPE} filesystem on ${FLL_MOUNTPOINT}\n\n"
								FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT} ${FLL_DOMOVEMOUNT}"
							elif [ -z "${FLL_UNION_MODULE}" ] || [ "${FLL_UNION_MODULE}" = "dmsetup" ]; then
								mkdir -p "${FLL_MOUNTPOINT}.mnt"
								if fll_mount "${FSTYPE}" "${FLL_BLOCKMNT}/${FLL_IMAGE_LOCATION}" "${FLL_MOUNTPOINT}.mnt" ; then
									printf "Mounted ${FSTYPE} filesystem on ${FLL_MOUNTPOINT}.mnt\n\n"
									FLL_DOMOVEMOUNT="${FLL_MOUNTPOINT}.mnt ${FLL_DOMOVEMOUNT}"
								else
									fll_umount ${FLL_DOUMOUNT}
									panic "Failed to mount ${FSTYPE} filesystem"
								fi
							else
								fll_umount ${FLL_DOUMOUNT}
								panic "Failed to mount ${FSTYPE} filesystem"
							fi
						else
							fll_umount ${FLL_DOUMOUNT}
							panic "Failed to identify filesystem type of live media image"
						fi
					else
						#
						# probe next device, add current mount to FLL_DOUMOUNT stack
						#
						FLL_DOUMOUNT="${FLL_BLOCKMNT} ${FLL_DOUMOUNT}"
					fi
				fi
			fi
		
			#
			# umount mount points in FLL_DOUMOUNT stack
			#
			fll_umount ${FLL_DOUMOUNT}
		
			#
			# break upon successful mount of live-media
			#
			if [ "${FLL_MEDIA_FOUND}" ]; then
				break 2
			fi
		done

		#
		# if we got here, we failed to find live media
		#
		
		if [ "${FLL_FROMHD_DEV}" ]; then
			continue
		fi
		
		#
		# start new probe line
		#
		printf "\n"
	done

	#
	# panic on failure to detect live media
	#
	if [ -z "${FLL_MEDIA_FOUND}" ]; then
		panic "Failed to detect live media"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-postmount

	#
	# mount a tmpfs over $rootmnt, reserving 10% system memory
	# Note: $rootmnt must be mounted with a fs != rootfs prior to run-init
	#
	printf "Mounting virtual memory tmpfs filesystem on ${rootmnt}..."
	if mount -n -t tmpfs -o size=90%,mode=755 tmpfs "${rootmnt}"; then
		printf "\n"
	else
		panic "Failed to mount tmpfs over ${rootmnt}"
	fi

	#
	# move all mounts in FLL_DOMOVEMOUNT stack to $rootmnt
	#
	if [ "${FLL_DOMOVEMOUNT}" ]; then
		printf "Moving all mounted filesystems to ${rootmnt}..."
		for mnt in ${FLL_DOMOVEMOUNT}; do
			if grep -q "${mnt}" /proc/mounts; then
				mkdir -p "${rootmnt}${mnt}"
				mount -n -o move "${mnt}" "${rootmnt}${mnt}"
			fi
		done
		printf "\n"
	fi

	#
	# prepare COW union filesystem, handle persistency
	#
	if [ "${FLL_PERSIST}" = "yes" ] && [ "${FLL_PERSIST_BLOCKMNT}" ]; then
		case "${FLL_PERSIST_BLOCKFSTYPE}" in
			ext*|reiser*|xfs|jfs|msdos|vfat)
				#
				# FLL_PERSIST_BLOCKMNT points to position of mounted fielsystem before it was moved
				# to the new root filesystem. Prepend ${rootmnt}.
				#
				FLL_UNION_COWMNTPNT="${rootmnt}${FLL_PERSIST_BLOCKMNT}"
				mkdir -p "${FLL_UNION_COWMNTPNT}"
				#
				# remount original fs containing live media rw (toram would umount it)
				#
				if grep -q "${FLL_UNION_COWMNTPNT}" /proc/mounts && mount -o remount,rw "${FLL_UNION_COWMNTPNT}" || \
					fll_mount ${FLL_PERSIST_BLOCKFSTYPE} ${FLL_PERSIST_BLOCKDEV} ${FLL_UNION_COWMNTPNT} rw; then
					printf "Reusing persistent data on ${FLL_PERSIST_BLOCKDEV#/dev/}...\n"
				else
					panic "Failed to remount persistent data on ${FLL_PERSIST_DEV#/dev/}"
				fi

				if [ -f "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}" ] ; then
					printf "Using ${FLL_PERSIST_FILE} filesystem-in-a-file..."
					if [ -z "${FLL_UNION_MODULE}" ] || [ "${FLL_UNION_MODULE}" = "dmsetup" ]; then
						#
						# setup loop device from persist file for snapshot
						#
						FLL_SNAP_DEV=$(losetup -f)
						if losetup ${FLL_SNAP_DEV} ${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE} ; then
							printf "\n"
						else
							panic "Failed to setup loop device for snapshot ${FLL_SNAP_DEV} from ${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}"
						fi
					else
						#
						# identify filesystem of loopback file, mount it and update FLL_UNION_COWMNTPNT
						#
						mkdir -p "${rootmnt}/fll/persist"
						if fll_finger_fstype "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}" && \
						  fll_mount "${FSTYPE}" "${FLL_UNION_COWMNTPNT}/${FLL_PERSIST_FILE}" \
						  "${rootmnt}/fll/persist" loop; then
							printf "\n"
							FLL_UNION_COWMNTPNT="${rootmnt}/fll/persist"
							#
							# We have now found a persistent file setup
							# We can revert any custom cowdir set by persist
							#
							FLL_UNION_COWDIR="/fll/cow"
						else
							panic "Failed to mount ${FLL_PERSIST_FILE} persistent filesystem-in-a-file"
						fi
					fi
				elif [ -n "${FLL_UNION_MODULE}" ] && [ "${FLL_UNION_MODULE}" != "dmsetup" ] && [ "${FLL_PERSIST_BLOCKFSTYPE}" != "msdos" ] && [ "${FLL_PERSIST_BLOCKFSTYPE}" != "vfat" ]; then
					# we're using aufs/unionfs and not on fat so it should be ok
					:
				else
					panic "Invalid/missing ${FLL_PERSIST_FILE} persistent filesystem-in-a-file"
				fi
				;;
			*)
				panic "Cannot create persistent filesystem with type ${FLL_PERSIST_BLOCKFSTYPE}"
				;;
		esac
	else
		FLL_UNION_COWMNTPNT="${rootmnt}"
		FLL_SNAP_DEV="/dev/mapper/${FLL_DISTRO_NAME}-snapshot"
	fi

	if [ -z "${FLL_UNION_MODULE}" ] || [ "${FLL_UNION_MODULE}" = "dmsetup" ]; then
		#
		# use losetup and dmsetup to create root snapshot
		if ! [ -b ${FLL_SNAP_DEV} ]; then
			# TODO size
			dd if=/dev/zero of=${rootmnt}/fll/snapshot bs=1M count=1 seek=511 2>/dev/null
			FLL_SNAP_DEV=$(losetup -f)
			losetup ${FLL_SNAP_DEV} ${rootmnt}/fll/snapshot
		fi
		FLL_ROOT_SIZE=$(ls -l "${rootmnt}/${FLL_MOUNTPOINT}.mnt/${FLL_IMAGE_FILE}" | awk '{print $5}')
		FLL_ROOT_DMSIZE=$((${FLL_ROOT_SIZE}/512))
		FLL_IMAGE_DEV=$(losetup -f)
		losetup ${FLL_IMAGE_DEV} "${rootmnt}/${FLL_MOUNTPOINT}.mnt/${FLL_IMAGE_FILE}"
		FLL_DM_MAP="0 ${FLL_ROOT_DMSIZE} snapshot ${FLL_IMAGE_DEV} ${FLL_SNAP_DEV} P 8"
		dmsetup create ${FLL_DISTRO_NAME}-live --table "${FLL_DM_MAP}"
		mkdir -p "${rootmnt}/${FLL_MOUNTPOINT}"
		# TODO FS ??? DONE
		if fll_finger_fstype /dev/mapper/${FLL_DISTRO_NAME}-live >/dev/null 2>&1 ; then
			if ! mount -t ${FSTYPE} /dev/mapper/${FLL_DISTRO_NAME}-live "${rootmnt}/${FLL_MOUNTPOINT}" ; then
				panic "Failed to mount live filesystem"
			fi
		else
			panic "Failed to recognise type of live filesystem"
		fi
		FLL_UNION_MOUNTPOINT="${FLL_MOUNTPOINT}"
	else
		#aufs || unionfs
		modprobe "${MODPROBE_OPTIONS}" "${FLL_UNION_MODULE}" >/dev/null 2>&1

		#
		# unioned filesystem mount points
		# persist may already have set FLL_UNION_COWDIR
		#
		FLL_UNION_MOUNTPOINT="/fll/${FLL_UNION_MODULE}"
		[ -z "$FLL_UNION_COWDIR" ] && FLL_UNION_COWDIR="/fll/cow"
		#
		# prepare COW union filesystem
		#
		mkdir -p "${rootmnt}${FLL_UNION_MOUNTPOINT}" "${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}"
		
		#
		# union module specific options
		#
		case "${FLL_UNION_MODULE}" in
			aufs)
				FLL_UNION_OPTIONS="br:${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}:${rootmnt}${FLL_MOUNTPOINT}"
				;;
			unionfs)
				FLL_UNION_OPTIONS="dirs=${FLL_UNION_COWMNTPNT}${FLL_UNION_COWDIR}=rw:${rootmnt}${FLL_MOUNTPOINT}=ro"
				;;
		esac
		
		#
		# mount the union COW filesystem
		#
		printf "Mounting ${FLL_UNION_MODULE} union filesystem..."
		if mount -t "${FLL_UNION_MODULE}" -o "${FLL_UNION_OPTIONS}" "${FLL_UNION_MODULE}" "${rootmnt}${FLL_UNION_MOUNTPOINT}"; then
			printf "\n"
		else
			panic "Failed to prepare ${FLL_UNION_MODULE} union filesystem"
		fi
	fi

	#
	# sanity check, ${rootmnt}${FLL_MOUNTPOINT} _must_ exist
	#
	if [ ! -d "${rootmnt}${FLL_MOUNTPOINT}" ]; then
		panic "Failed to find ${FLL_MOUNTPOINT} on ${rootmnt}"
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-unionmount

	printf "Preparing live filesystem on ${rootmnt}...\n"
	
	#
	# create links on $rootmnt to real filesystem
	#
	for dir in ${rootmnt}${FLL_UNION_MOUNTPOINT}/*; do
		if [ -d "${dir}" ]; then
			case "${dir##*/}" in
				dev|media|proc|run|sys|tmp)
					#
					# these should stay out of the unioned filesystem mount point
					# keep them directly on the ramdisk, they are handled below
					#
					continue
					;;
				*)
					#
					# link everything else to read-write unioned filesystem
					#
					if [ -L "${dir}" ]; then
						#
						# /lib64 -> /lib symlink handling
						#
						ln -sf "$(readlink ${dir})" "${rootmnt}/${dir##*/}"
					else
						#
						# bind mount links to read write union
						#
						mkdir -p "${rootmnt}/${dir##*/}"
						mount -n -o bind "${dir}" "${rootmnt}/${dir##*/}"
					fi
					;;
			esac
		fi
	done

	# Scan for firmware if requested
	if [ -n "$FLL_FIRMWARE" ]; then
		# FLL_FIRMWARE_FOUND is set once the firmware is found (and copied)
		unset FLL_FIRMWARE_FOUND
		# start by checking mounted fs
		# they have been moved by now to ${rootmnt}/fll/
		# FLL_FIRMMNTS holds "devices" which have been checked
		unset FLL_FIRMMNTS
		for dev in $(ls -d ${rootmnt}/fll/*) ; do
			if [ -d ${dev} ]; then
				FLL_FIRMMNTS="${FLL_FIRMMNTS} ${dev##*/}"
				if [ -d ${dev}/${FLL_IMAGE_DIR}/firmware ]; then
					FLL_FIRMWARE_FOUND="${dev}"
					if cp -r ${dev}/${FLL_IMAGE_DIR}/firmware/* ${rootmnt}/lib/firmware/ ; then
						printf "Copied firmware from ${dev##*/}\n"
					fi
					break
				fi
			fi
		done
		# means firmware is not on a mounted fs
		if [ -z "${FLL_FIRMWARE_FOUND}" ]; then
			fll_firmware
		fi
	fi

	#
	# debug checkpoint
	#
	maybe_break fll-bindmount

	#
	# prepare /dev /media /proc /sys and /selinux
	#
	for dir in dev media proc run sys selinux; do
		mkdir -p -m 0755 "${rootmnt}/${dir}"
	done

	#
	# tmp with correct permissions for users
	#
	mkdir -m 1777 "${rootmnt}/tmp"

	#
	# debug checkpoint
	#
	maybe_break fll-bottom

	#
	# alsa should not be persistent
	#
	rm -f ${rootmnt}/var/lib/alsa/asound.state

	#
	# disable persistent udev rules. we have "persistency" logic for data but
	# we should remain hardware agnostic
	#
	rm -f ${rootmnt}/etc/udev/rules.d/70-persistent-*.rules

	#
	# create udev rule for persistent symlink to device live media was found on
	#
	printf "KERNEL==\"%s\", SYMLINK+=\"fll\"\n" \
		"${FLL_MEDIA_FOUND#/dev/}" >  ${rootmnt}/etc/udev/rules.d/70-fll-live.rules
	printf "KERNEL==\"%s\", ENV{ID_CDROM}==\"?*\", SYMLINK+=\"fll-cdrom\"\n" \
		"${FLL_MEDIA_FOUND#/dev/}" >> ${rootmnt}/etc/udev/rules.d/70-fll-live.rules
	
	#
	# disable movement of static $rootmnt/dev by scripts/init-bottom/udev
	#
	export no_static_dev="1"

	printf "\nStarting init process...\n\n"
}
###############################################################################
